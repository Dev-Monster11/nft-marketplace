import React from 'react';
import { UnrealAdapter } from "./UnrealAdapter"
import { WebRtcPlayer } from './WebRtcPlayer';

const HOST = "10.10.1.161"
const PORT = 80

interface SocketMessage {
    type: 'config' | 'playerCount' | 'answer' | 'iceCandidate';
    peerConnectionOptions?: RTCConfiguration;
    candidate?: RTCIceCandidateInit;
}

export interface UnrealAdapterOptions {
    container: HTMLElement;
    host: string;
    port: number;
    useSSL?: boolean;
    useMic?: boolean;
    matchViewPort?: boolean;
}
  
const WS_OPEN_STATE = 1;
  
const ToClientMessageType = {
    QualityControlOwnership: 0,
    Response: 1,
    Command: 2,
    FreezeFrame: 3,
    UnfreezeFrame: 4,
    VideoEncoderAvgQP: 5,
    LatencyTest: 6,
    InitialSettings: 7,
};
  const MessageType = {
    /**********************************************************************/
  
    /*
     * Control Messages. Range = 0..49.
     */
    IFrameRequest: 0,
    RequestQualityControl: 1,
    MaxFpsRequest: 2,
    AverageBitrateRequest: 3,
    StartStreaming: 4,
    StopStreaming: 5,
    LatencyTest: 6,
    RequestInitialSettings: 7,
  
    /**********************************************************************/
  
    /*
     * Input Messages. Range = 50..89.
     */
  
    // Generic Input Messages. Range = 50..59.
    UIInteraction: 50,
    Command: 51,
  
    // Keyboard Input Message. Range = 60..69.
    KeyDown: 60,
    KeyUp: 61,
    KeyPress: 62,
  
    // Mouse Input Messages. Range = 70..79.
    MouseEnter: 70,
    MouseLeave: 71,
    MouseDown: 72,
    MouseUp: 73,
    MouseMove: 74,
    MouseWheel: 75,
  
    // Touch Input Messages. Range = 80..89.
    TouchStart: 80,
    TouchEnd: 81,
    TouchMove: 82,
  
    // Gamepad Input Messages. Range = 90..99
    GamepadButtonPressed: 90,
    GamepadButtonReleased: 91,
    GamepadAnalog: 92,
  
    /**************************************************************************/
  };
  
  export enum BusinessMessageType {
    init = '0',
  }

interface AdapterMessage {
    _message: any;
    _date: string;
    _code: string;
}

class UnrealAdapterHook {
    onAnswer?: (o?: any) => void;
    onConfig?: (o?: any) => void;
    onIceCandidate?: (o?: any) => void;
    onPlayerCount?: (o?: any) => void;
    onMessage?: (m?: AdapterMessage) => void;
}

interface SocketMessage {
    type: 'config' | 'playerCount' | 'answer' | 'iceCandidate';
    peerConnectionOptions?: RTCConfiguration;
    candidate?: RTCIceCandidateInit;
}

const PixelStreamer: React.FC = () => {
    return (
        <div className="App">
            <header className="App-header">
                <Mirror></Mirror>
            </header>
        </div>
    );
}
interface Props { }
interface State { };
class Mirror extends React.Component<Props, State, UnrealAdapterHook> {
    private unrealAdapterOption: UnrealAdapterOptions;
    // @ts-ignore
    public player: WebRtcPlayer;
    // @ts-ignore
    private ws: WebSocket;
    private videoResizeTimeout: any;

    constructor(props:any, options: UnrealAdapterOptions) {
        super(props);
        this.unrealAdapterOption = options;
    }
    hook = new UnrealAdapterHook()
  
//    video_reference = React.createRef<HTMLVideoElement>();

    public load() {
        this.ws = new WebSocket(
            this.unrealAdapterOption.useSSL
              ? 'wss://'
              : 'ws://' + this.unrealAdapterOption.host + ':' + this.unrealAdapterOption.port,
          );

        this.ws.onmessage = (event:any ) => {
            const data: SocketMessage = JSON.parse(event.data);
            switch (data.type) {
            case 'answer':
                this.player.handleReceiveAnswer(data);
                if (this.hook.onAnswer) {
                    this.hook.onAnswer(data);
                }
                break;
            case 'config':
                if (data.peerConnectionOptions) {
                this.hook.onPlayerConfig(data.peerConnectionOptions);
                }
                break;
            case 'iceCandidate':
                if (this.player && data.candidate) {
                this.player.handleCandidateFromServer(data.candidate);
                }
                if (this.onIceCandidate) {
                this.onIceCandidate(data.candidate);
                }
                break;
            case 'playerCount':
            default:
            }
        };
        window.addEventListener('orientationchange', () => {
            this.onOrientationChange();
        });
    }

    async componentDidMount() {
        if (this.video_reference.current) {
            // let video_stream: MediaStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false })
            this.video_reference.current.srcObject = video_stream
        };
    };
    render() {
        return (
            <video ref={this.video_reference} id="player" autoPlay style={{"width":'100vw', 'height':'auto'}}>
            </video>
        );
    };
};

export default PixelStreamer;
// const pixelStreamer = function(){
//     navigator.mediaDevices
//   .getUserMedia({ video: true, audio: false })
//   .then((stream) => (video.srcObject = stream))
//   .catch((error) => {
//     console.warn("【camera】", error);
//     return navigator.mediaDevices.getDisplayMedia({ audio: false });
//   })
//   .then((stream) => (video.srcObject = stream))
//   .catch((error) => {
//     console.warn("【screen capture】", error);
//     setupCanvas();
//   })
//   .finally(() => {
//     setupSignal();
//     window.stream = video.srcObject || canvas.captureStream();
//     stream.track = stream.getVideoTracks()[0];
//     console.log("✅ Unreal Simulator is running!");
//   });

// }